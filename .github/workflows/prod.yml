name: Deploy Prod to EC2
on:
  push:
    branches: [ "main" ]

permissions:
  contents: read

concurrency:
  group: prod-deploy
  cancel-in-progress: false

jobs:
  build-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-java@v4
        with:
          distribution: corretto
          java-version: "21"
      - uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: ${{ runner.os }}-gradle-
      - name: Run tests
        run: ./gradlew test --no-daemon

  deploy:
    needs: build-test
    runs-on: self-hosted
    env: # 필요한 값들을 정의(키는 Secret 유지)
      APP_DIR: /home/ubuntu/lv3-final-mission
      BRANCH: main
      REPO_URL: https://github.com/nourzoo/lv3-final-mission.git
      INCLUDE_DB: "false"            # prod DB 분리 운영이면 false
      ENV_FILE: .env                 # 배포 시 사용할 env 파일
    steps:
      - name: Deploy (local on self-hosted)
        shell: bash
        run: |
          set -euo pipefail

          APP_DIR="${APP_DIR}"
          BRANCH="${BRANCH:-main}"
          REPO_URL="${REPO_URL:-}"
          INCLUDE_DB="${INCLUDE_DB:-false}"
          ENV_FILE_INPUT="${ENV_FILE:-.env.prod}"

          # 디렉터리 준비
          sudo mkdir -p "${APP_DIR}"
          sudo chown -R "$USER":"$USER" "${APP_DIR}"

          # 초기 clone (없을 때만)
          if [ ! -d "${APP_DIR}/.git" ]; then
            if [ -z "${REPO_URL}" ]; then
              echo "REPO_URL is required for initial clone" >&2
              exit 1
            fi
            git clone "${REPO_URL}" "${APP_DIR}"
          fi

          cd "${APP_DIR}"
          git fetch --all --prune
          git checkout "${BRANCH}"
          git pull --ff-only origin "${BRANCH}"

          # 환경파일 확인
          if [ ! -f "${ENV_FILE_INPUT}" ]; then
            echo "${ENV_FILE_INPUT} not found on runner. Create it with prod secrets." >&2
            exit 1
          fi

          # Compose 파일 결정
          COMPOSE_ARGS="-f docker-compose.yml"
          if [ "${INCLUDE_DB}" = "true" ] && [ -f "docker-compose.db.yml" ]; then
            COMPOSE_ARGS="${COMPOSE_ARGS} -f docker-compose.db.yml"
          fi

          # 배포
          docker compose ${COMPOSE_ARGS} --env-file "${ENV_FILE_INPUT}" up -d --build
          docker image prune -f
